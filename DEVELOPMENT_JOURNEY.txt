DEVELOPMENT JOURNEY: ANCESTORLENS
A Personal Reflection on Building a Genealogy Platform for African Heritage Preservation

When I first conceived of AncestorLens, I was driven by a simple yet profound realization: existing genealogy platforms were built with Western family structures in mind, completely overlooking the rich oral traditions, burial site significance, and cultural memory preservation that are central to African genealogical practices. This wasn't just a technical project for me—it was personal. I wanted to create something that would help families like mine preserve stories that might otherwise be lost forever.

The journey began with careful consideration of the technology stack. I chose React with TypeScript because I needed a modern, type-safe framework that would allow for rapid development while maintaining code quality. Vite was a natural choice for the build tool—its speed during development was a game-changer, especially when I was iterating on complex components like the interactive family tree. Tailwind CSS became my styling companion, allowing me to build a responsive, modern interface without getting bogged down in custom CSS files.

Firebase was perhaps the most critical decision. I needed a backend that could handle authentication, real-time data synchronization, and file storage without requiring me to build and maintain a traditional server infrastructure. Firestore's real-time capabilities meant that family members could see updates instantly, which felt essential for a collaborative genealogy platform. Cloudinary integrated seamlessly for handling image and audio uploads, which was crucial for the cultural memory archive feature.

The initial development phase was exciting. I started with the authentication system, getting users signed up and logged in. Then I moved to the family tree builder, which was one of the most challenging components. Building an interactive, draggable family tree using React Flow required careful state management and relationship mapping. I spent days working through edge cases—what happens when someone has multiple spouses? How do we handle adopted children? These weren't just technical questions; they reflected real family complexities.

The burial site mapping feature was particularly meaningful to me. In many African cultures, burial sites hold deep spiritual and cultural significance. I integrated Leaflet for map visualization and Google Maps API for geocoding, allowing users to mark and preserve the locations of their ancestors' final resting places. The privacy controls were essential here—not all burial sites should be publicly accessible, and families needed granular control over who could see what.

Cultural memories became the heart of the platform. The ability to upload audio recordings of oral stories, combined with images and detailed descriptions, created a rich archive of family heritage. This feature required careful handling of file uploads, especially for audio files which could be quite large. I implemented progress indicators and error handling to ensure users didn't lose their precious memories during upload.

Then came the challenges. The first major hurdle was Firebase security rules. I initially implemented a feature that would allow families to "hand down" their genealogical data to younger generations, but the security rules I wrote were too restrictive. Users started seeing "Missing or insufficient permissions" errors, and data would disappear after login and logout. This was terrifying—imagine families losing their carefully documented heritage because of a configuration error.

I spent hours debugging, thinking it was a code issue. I checked authentication flows, verified user IDs, tested data fetching—everything seemed correct in the application code. It wasn't until I carefully reviewed the Firebase security rules that I realized the problem. The rules were blocking legitimate access because they were checking for conditions that didn't account for document creation versus document updates. I had to simplify the rules significantly, ensuring users could only access their own data while maintaining security.

The data persistence issue was another significant challenge. I noticed that data would sometimes disappear after users logged out and back in. This led me to implement a hybrid approach: the application now prioritizes localStorage for instant rendering, then fetches from Firestore and merges the data. This ensures that even if there are network issues or permission problems, users can still see their locally stored data. The merge logic prevents duplicates while ensuring no data is lost.

Deployment to Vercel brought its own set of challenges. Initially, my test files were causing TypeScript compilation errors during the build process. The build system was trying to compile test files that weren't meant for production. I had to configure TypeScript to exclude test files from the build, which required careful adjustment of the tsconfig.json file. This taught me the importance of separating development and production concerns from the start.

Testing became a crucial part of the development process, though I was initially hesitant. Would tests break my code? Would they interfere with the platform? I quickly learned that well-written tests actually protect the codebase rather than endanger it. I set up Vitest with React Testing Library, creating comprehensive mocks for Firebase, Cloudinary, and geocoding services. The tests run in complete isolation, using mocked data and services, so they never touch production data or make real API calls.

The unit tests covered critical service functions—geocoding addresses, uploading files to Cloudinary, and managing family member data. Integration tests verified that components worked together correctly, testing user flows like adding a family member or uploading a cultural memory. These tests caught several bugs before they could reach production, including edge cases I hadn't considered during initial development.

One of the most frustrating issues was with Cloudinary file access. Some uploaded files, particularly PDFs and ZIP archives, were being blocked for delivery. The error messages weren't helpful, and users were confused when they couldn't access their own documents. I had to dig deep into Cloudinary's settings, discovering that upload presets needed specific configurations for public access, and that PDF/ZIP delivery had to be explicitly enabled in the security settings. I implemented comprehensive error messages that guide users through fixing these issues, turning a frustrating experience into an educational one.

The archives feature required careful handling of different file types. I implemented multiple URL format attempts, trying various Cloudinary transformation options to access files. When all attempts failed, the application now provides detailed, step-by-step instructions for users to fix their Cloudinary settings. This proactive error handling transformed a potential support nightmare into a self-service solution.

Throughout development, I kept returning to the core mission: preserving African heritage. Every feature decision was filtered through this lens. The family tree needed to handle complex relationships common in African families. The burial site mapping needed to respect cultural significance. The cultural memory archive needed to prioritize oral traditions, which are often overlooked in digital genealogy platforms.

The responsive design was non-negotiable. Many users in Africa access the internet primarily through mobile devices, so the platform had to work beautifully on phones and tablets. I tested extensively across different screen sizes, ensuring that the family tree remained usable even on small screens, and that map interactions worked smoothly with touch gestures.

As the platform neared completion, I implemented comprehensive error handling throughout. Services now return empty arrays instead of throwing errors, preventing the UI from breaking when there are network issues or permission problems. The application gracefully degrades, showing cached data when live data isn't available, and providing clear feedback when actions fail.

The testing infrastructure I built became invaluable. Running tests before each deployment gave me confidence that new changes hadn't broken existing functionality. The integration tests, in particular, caught subtle bugs where components didn't interact correctly, saving me from discovering these issues in production.

Looking back, the development journey was marked by both technical challenges and personal fulfillment. Each bug fixed, each feature completed, felt like a step toward preserving something precious. The platform now handles family trees with complex relationships, preserves burial site locations with privacy controls, and archives cultural memories in multiple formats.

The most rewarding moments came when I realized the platform was actually working as intended—families could document their heritage, preserve oral stories, and map burial sites in a way that respected their cultural practices. The technical challenges were significant, but they were worth solving because the end result serves a meaningful purpose.

I learned that building a platform like this requires more than just technical skills. It requires understanding the cultural context, respecting user needs, and being willing to iterate when something doesn't work. The Firebase security rules taught me that sometimes the problem isn't in your code—it's in your configuration. The data persistence issues taught me the value of defensive programming and graceful degradation.

The testing journey was particularly educational. I went from being skeptical about tests to understanding their value as a safety net. The comprehensive test suite I built doesn't just verify that code works—it documents expected behavior and catches regressions before they reach users.

Deployment challenges taught me the importance of separating development and production concerns. Test files shouldn't be compiled for production. Environment variables need to be carefully managed. Build processes need to account for all the tools and services the application depends on.

Perhaps most importantly, I learned that building software is an iterative process. The first version of the family tree builder was functional but clunky. The first version of the cultural memory upload had basic error handling but didn't guide users when things went wrong. Each iteration improved the user experience, making the platform more robust and more user-friendly.

The platform is now live, serving families who want to preserve their heritage. It handles complex family relationships, preserves oral traditions through audio recordings, maps burial sites with cultural sensitivity, and provides a secure, private space for families to document their history. The technical challenges were significant, but they were all solvable with patience, research, and a commitment to the mission.

Building AncestorLens has been one of the most challenging and rewarding experiences of my development career. It's not just a genealogy platform—it's a tool for preserving stories, traditions, and connections that might otherwise be lost. Every bug fixed, every feature added, every test written, contributes to that mission. And that makes all the late nights, debugging sessions, and configuration headaches completely worth it.

